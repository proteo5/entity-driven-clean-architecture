# Entity-Driven Clean Architecture

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![GitHub stars](https://img.shields.io/github/stars/[tu-usuario]/entity-driven-clean-architecture)](https://github.com/[tu-usuario]/entity-driven-clean-architecture/stargazers)

> A practical, explicit, and scalable architecture for API-first backends

---

## üöÄ Quick Start

**Core Principles:**
- **Explicit over Implicit** - Always
- **Organized by Entity** - Not by technical layer
- **Result Envelope** - Structured responses with explicit codes
- **Nested Structure** - DataIn/DataOut/Messages in one file
- **UTC Everywhere** - Core only works in UTC
- **Snowflake IDs** - Distributed ID generation

**Example:**
```csharp
// Single file contains everything
public class UserCCreate {
    public class DataIn { ... }
    public class DataOut { ... }
    public static class Messages { ... }
    
    public async Task<Result> Handler(DataIn input) {
        // Clean ‚Üí Validation ‚Üí Business Rules ‚Üí Process
    }
}
```

---

## üìñ Documentation

- [Full White Paper](#entity-driven-clean-architecture-for-api-first-backends) (below)
- [C# Examples](./examples/csharp/)
- [Python Examples](./examples/python/)
- [TypeScript Examples](./examples/typescript/)

---

## üí° Why This Architecture?

- ‚úÖ **60% less files** - Nested structure keeps related code together
- ‚úÖ **Testable Core** - 100% independent of infrastructure
- ‚úÖ **Explicit codes** - `USER_CREATE:VALIDATION:EMAIL_REQUIRED` for debugging
- ‚úÖ **Protocol agnostic** - Works with REST, GraphQL, gRPC
- ‚úÖ **Distributed ready** - Snowflake IDs for microservices

---

## üõ†Ô∏è Implementation Examples

### C# (.NET 6+)
```csharp
public class UserCCreate {
    public class DataIn {
        public string Email { get; set; }
        public string Name { get; set; }
    }
    
    public async Task<Result> Handler(DataIn input) {
        // Implementation with structured codes
        return new Result(
            state: "success",
            code: "USER_CREATE:SUCCESS",
            data: output
        );
    }
}
```

[See complete C# examples ‚Üí](./examples/csharp/)

### Python (FastAPI)
```python
class UserCCreate:
    @dataclass
    class DataIn:
        email: str
        name: str
    
    async def handler(self, input: DataIn) -> Result[DataOut]:
        # Implementation with structured codes
        return Result(
            state="success",
            code="USER_CREATE:SUCCESS",
            data=output
        )
```

[See complete Python examples ‚Üí](./examples/python/)

### TypeScript (Express)
```typescript
export namespace UserCCreate {
    export interface DataIn {
        email: string;
        name: string;
    }
    
    export class Messages { ... }
}

export class UserCCreate {
    async handler(input: UserCCreate.DataIn): Promise<Result> {
        // Implementation with structured codes
    }
}
```

[See complete TypeScript examples ‚Üí](./examples/typescript/)

---

## üìä Result Envelope with Structured Codes

Every operation returns a `Result<T>` with **explicit, structured codes**:
```
Format: [OPERATION]:[SECTION]:[REASON]

Examples:
‚úÖ USER_CREATE:SUCCESS
‚úÖ USER_CREATE:VALIDATION:EMAIL_REQUIRED
‚úÖ USER_CREATE:BUSINESS_RULE:EMAIL_EXISTS
‚úÖ ORDER_CREATE:ERROR:DATABASE_CONNECTION
```

**Benefits:**
- üîç Easy debugging from logs
- ü§ñ Clients can make programmatic decisions
- üìä Metrics and alerts by section
- üö´ No text interpretation needed

---

## üåü Star History

If you find this architecture useful, please ‚≠ê star the repo!

---

## üìÑ License

MIT License - feel free to use in commercial and open source projects.

---

## ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

---

## üìß Contact

Questions? Open an issue or discussion in this repository.

---



<!-- White Paper Content Starts Here -->

---

# Entity-Driven Clean Architecture for API-First Backends

**Version 1.0 - Final**  
**Date:** October 2025

---

## Resumen Ejecutivo

**Entity-Driven Clean Architecture** es una arquitectura para backends API-first, agn√≥stica de lenguaje, que organiza el c√≥digo por entidades de negocio utilizando convenciones expl√≠citas para maximizar claridad, testabilidad y mantenibilidad.

### Ventajas Principales
- **Testabilidad Total**: Core 100% independiente de infraestructura
- **Agn√≥stica**: Funciona con REST, GraphQL, gRPC u otros protocolos
- **Organizaci√≥n Clara**: Estructura por entidades, no por capas t√©cnicas
- **Expl√≠cita**: Nombres descriptivos sobre abreviaciones
- **Escalabilidad**: Separaci√≥n clara entre l√≥gica de negocio e infraestructura
- **Mantenibilidad**: 60% menos archivos con estructura nested cohesiva

### Cu√°ndo Usarla
- Backends API-first (REST, GraphQL, gRPC)
- Proyectos que requieren alta testabilidad
- Sistemas que evolucionar√°n en complejidad
- Equipos que valoran consistencia y claridad
- Arquitecturas distribuidas y microservicios

---

## Contexto y Motivaci√≥n

Los backends tradicionales organizados por capas t√©cnicas (Controllers, Services, Repositories) presentan problemas:

- **Dificultad para encontrar c√≥digo**: ¬øD√≥nde est√° la l√≥gica de "registrar usuario"?
- **Acoplamiento a infraestructura**: Tests que requieren bases de datos, servicios externos
- **Inconsistencia**: Cada desarrollador estructura el c√≥digo diferente
- **Cambios en protocolo requieren refactoring**: Cambiar de REST a GraphQL implica reescribir
- **Archivos dispersos**: 5+ archivos para entender una operaci√≥n

**Entity-Driven Clean Architecture** resuelve estos problemas mediante:
1. Organizaci√≥n por **entidades de negocio** (no por capas t√©cnicas)
2. **Core** completamente independiente de infraestructura
3. **Convenci√≥n expl√≠cita** con estructura nested cohesiva
4. **Snowflake IDs** para sistemas distribuidos
5. **UTC estricto** en toda la l√≥gica de negocio

---

## Principios Fundamentales

### 1. Expl√≠cito sobre Impl√≠cito - SIEMPRE

**El principio m√°s importante de esta arquitectura.**

```
‚úÖ CORRECTO - Expl√≠cito
UserCCreate.DataIn    # Claro: datos que ENTRAN
UserCCreate.DataOut   # Claro: datos que SALEN
UserCCreate.Messages  # Claro: mensajes multiidioma

‚ùå INCORRECTO - Impl√≠cito
UserCRegisterI        # ¬øI de qu√©? ¬øInput? ¬øInterface?
Input                 # ¬øInput de qu√©?
DTO                   # Demasiado gen√©rico
```

### 2. Separaci√≥n Core vs Infrastructure

**CORE (L√≥gica de Negocio)**
- NO conoce REST, GraphQL, gRPC
- NO conoce bases de datos (SQL, MongoDB, etc.)
- NO conoce servicios externos (Email, SMS, WhatsApp)
- NO conoce el reloj del sistema (DateTime.Now)
- ES 100% testeable sin mocks complejos

**INFRASTRUCTURE**
- Adaptadores a protocolos (REST, GraphQL, gRPC)
- Implementaciones de bases de datos
- Clientes de servicios externos
- Autenticaci√≥n y autorizaci√≥n
- Manejo de fecha/hora del sistema
- Cach√© (Redis, Memory)

### 3. Organizaci√≥n por Entidad

El c√≥digo se agrupa por **entidad de negocio**, no por tipo t√©cnico:

```
‚úÖ CORRECTO (Por Entidad)
Core/
  Entities/
    UsersQC/
    CompaniesQC/
    OrdersQC/

‚ùå INCORRECTO (Por Capa T√©cnica)
Core/
  Services/
  Repositories/
  DTOs/
```

### 4. Inversi√≥n de Control (IoC) y Dependency Injection

**El Core define QU√â necesita (interfaces), Infrastructure define C√ìMO lo hace (implementaciones).**

```
‚ùå MAL - Core depende de Infrastructure
Core ‚Üí Infrastructure (acoplamiento directo)

‚úÖ BIEN - Ambos dependen de abstracciones
Core ‚Üí Interfaces ‚Üê Infrastructure
```

**El Core NO sabe:**
- ‚ùå Si usa SQL Server, PostgreSQL, MongoDB
- ‚ùå Si hay cach√© (Redis, MemoryCache)
- ‚ùå C√≥mo se env√≠an emails (SMTP, SendGrid, AWS SES)
- ‚ùå C√≥mo se env√≠an SMS (Twilio, AWS SNS)

**El Core SOLO pide:**
- ‚úÖ "Dame un usuario por ID"
- ‚úÖ "Guarda este usuario"
- ‚úÖ "Env√≠a un email a esta direcci√≥n"

### 5. Convenci√≥n de Nomenclatura QC

Cada archivo/clase sigue el patr√≥n: `[Entity][Q|C][Action]`

- **Q (Query)**: Lectura de datos, no modifica estado
- **C (Command)**: Escritura, modifica estado del sistema

**Ejemplos:**
- `UserCCreate` - Command para crear usuario
- `UserQGetAll` - Query para obtener todos los usuarios
- `CompanyCCreate` - Command para crear compa√±√≠a
- `CompanyQGetByID` - Query para obtener compa√±√≠a por ID

### 6. Result Envelope Pattern

**TODO el Core retorna respuestas envueltas en Result<T>:**

```
Result<T> {
    state: string          // "success" | "unsuccess" | "empty" | "invalid" | "error"
    code: string          // C√≥digo √∫nico (ej: "USER_CREATE:EMAIL_EXISTS")
    message: Messages     // Mensajes multiidioma
    data: T              // Datos de respuesta (Output DTO)
    invalidFields: []    // Campos inv√°lidos
}
```

**Estados posibles:**
- `success` - Operaci√≥n exitosa con datos
- `unsuccess` - Operaci√≥n fallida por regla de negocio
- `empty` - Operaci√≥n exitosa pero sin datos (Query sin resultados)
- `invalid` - Datos de entrada inv√°lidos
- `error` - Error del sistema/excepci√≥n

### 7. Zona Horaria UTC

**TODO el sistema maneja UTC internamente:**
- Core trabaja exclusivamente en UTC
- Infrastructure guarda/lee en UTC
- Presentation Layer convierte de timezone usuario ‚Üí UTC (entrada)
- Presentation Layer convierte de UTC ‚Üí timezone usuario (salida)

### 8. Snowflake IDs (Fuertemente Recomendado)

**Se recomienda usar IDs basados en Twitter Snowflake en lugar de auto-increment integers:**

**Estructura de Snowflake ID:**
```
 0                   41           51     64
 |--------------------|-----------|------|
 timestamp (41 bits) | node (10) | seq (12)
```

**Ventajas sobre Auto-Increment:**
- ‚úÖ **Distribuci√≥n**: M√∫ltiples servidores pueden generar IDs sin conflictos
- ‚úÖ **Performance**: No requiere consultar base de datos para obtener ID
- ‚úÖ **Seguridad**: No revela cantidad de registros
- ‚úÖ **Ordenamiento**: IDs m√°s recientes tienen valores mayores
- ‚úÖ **Microservicios**: Ideal para arquitecturas distribuidas

---

## Arquitectura

### Diagrama de Capas

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         PRESENTATION LAYER                  ‚îÇ
‚îÇ      (REST / GraphQL / gRPC)                ‚îÇ
‚îÇ  - Autenticaci√≥n                            ‚îÇ
‚îÇ  - Autorizaci√≥n                             ‚îÇ
‚îÇ  - Validaci√≥n de entrada                    ‚îÇ
‚îÇ  - Conversi√≥n Timezone (User ‚Üî UTC)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            CORE LAYER                       ‚îÇ
‚îÇ         (Business Logic - Pure)             ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  Commands & Queries                         ‚îÇ
‚îÇ    - UserCCreate                            ‚îÇ
‚îÇ    - UserQGetByID                           ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  Each operation contains:                   ‚îÇ
‚îÇ    - Handler() method                       ‚îÇ
‚îÇ    - DataIn (nested)                        ‚îÇ
‚îÇ    - DataOut (nested)                       ‚îÇ
‚îÇ    - Messages (nested)                      ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  Depends on:                                ‚îÇ
‚îÇ    - Interfaces (IUserRepository, etc.)     ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚ö†Ô∏è  NO dependencies on infrastructure      ‚îÇ
‚îÇ  ‚ö†Ô∏è  ALL dates in UTC                       ‚îÇ
‚îÇ  ‚ö†Ô∏è  ALL returns Result<T>                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ implements
                  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       INFRASTRUCTURE LAYER                  ‚îÇ
‚îÇ    (External Dependencies)                  ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  - Database implementations                 ‚îÇ
‚îÇ  - External services (Email, SMS)           ‚îÇ
‚îÇ  - File storage                             ‚îÇ
‚îÇ  - Cache (Redis, Memory)                    ‚îÇ
‚îÇ  - Date/Time providers (UTC)                ‚îÇ
‚îÇ  - Snowflake ID generators                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Estructura de Proyectos

```
MySolution/
‚îÇ
‚îú‚îÄ‚îÄ MyProject.Core/                    # ‚Üê Business Logic (NO dependencies)
‚îÇ   ‚îú‚îÄ‚îÄ Common/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Result.cs                  # Result envelope
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Messages.cs                # Messages DTO
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ResultsStates.cs           # State constants
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UsersQC/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.{lang}            # Entity (persistence model)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserCCreate.{lang}     # Command with nested DataIn/DataOut/Messages
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserCUpdate.{lang}
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserQGetByID.{lang}    # Query with nested DataIn/DataOut/Messages
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserQGetAll.{lang}
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompaniesQC/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Company.{lang}
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompanyCCreate.{lang}
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CompanyQGetByID.{lang}
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrdersQC/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Order.{lang}
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OrderCCreate.{lang}
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ OrderQGetByUser.{lang}
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/                    # ‚Üê Contracts
‚îÇ       ‚îú‚îÄ‚îÄ IUserRepository.cs
‚îÇ       ‚îú‚îÄ‚îÄ IEmailService.cs
‚îÇ       ‚îú‚îÄ‚îÄ ISnowflakeIdGenerator.cs
‚îÇ       ‚îî‚îÄ‚îÄ IDateTimeProvider.cs
‚îÇ
‚îú‚îÄ‚îÄ MyProject.Infrastructure/          # ‚Üê External Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ Database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserRepository.{lang}
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CompanyRepository.{lang}
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EmailService.{lang}
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SMSService.{lang}
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DateTimeProvider.{lang}    # Always returns UTC
‚îÇ   ‚îú‚îÄ‚îÄ IdGeneration/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SnowflakeIdGenerator.{lang}
‚îÇ   ‚îî‚îÄ‚îÄ Cache/
‚îÇ       ‚îú‚îÄ‚îÄ RedisCacheService.{lang}
‚îÇ       ‚îî‚îÄ‚îÄ MemoryCacheService.{lang}
‚îÇ
‚îú‚îÄ‚îÄ MyProject.API.REST/                # ‚Üê REST Interface
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UsersController.{lang}     # Handles timezone conversion
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CompaniesController.{lang}
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthenticationMiddleware
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AuthorizationMiddleware
‚îÇ   ‚îî‚îÄ‚îÄ Program.{lang}                 # DI configuration
‚îÇ
‚îî‚îÄ‚îÄ MyProject.Helpers/                 # ‚Üê Utility Libraries
    ‚îî‚îÄ‚îÄ StringExtensions.{lang}        # Clean helpers
```

---

## Estructura de Archivos (Nested Pattern)

### Comparaci√≥n: Antes vs Ahora

**ANTES (5 archivos por operaci√≥n):**
```
UsersQC/
  ‚îú‚îÄ‚îÄ User.cs
  ‚îú‚îÄ‚îÄ UserCRegister.cs
  ‚îú‚îÄ‚îÄ UserCRegisterI.cs      ‚Üê Archivo separado
  ‚îú‚îÄ‚îÄ UserCRegisterO.cs      ‚Üê Archivo separado
  ‚îî‚îÄ‚îÄ UserCRegisterM.cs      ‚Üê Archivo separado

Uso:
var input = new UserCRegisterI { ... };
```

**AHORA (2 archivos - 60% reducci√≥n):**
```
UsersQC/
  ‚îú‚îÄ‚îÄ User.cs                # Entity compartida
  ‚îî‚îÄ‚îÄ UserCCreate.cs         # Todo junto, cohesivo
      ‚îú‚îÄ‚îÄ class DataIn       # Nested
      ‚îú‚îÄ‚îÄ class DataOut      # Nested
      ‚îú‚îÄ‚îÄ class Messages     # Nested
      ‚îî‚îÄ‚îÄ Handler()

Uso (Expl√≠cito):
var input = new UserCCreate.DataIn { ... };
var result = await command.Handler(input);
UserCCreate.DataOut output = result.Data;
```

### Anatom√≠a de un Command/Query

**Pseudoc√≥digo:**
```
// UserCCreate.{lang} - Un archivo, todo incluido

class UserCCreate {
    
    // Nested Classes - DTOs
    class DataIn {
        email: string
        name: string
        password: string
    }
    
    class DataOut {
        userId: long        // Snowflake ID
        email: string
        name: string
        createdAt: datetime // UTC
    }
    
    static class Messages {
        static function Get(language, key): Messages
    }
    
    // Dependencies (inyectadas)
    private idGenerator: ISnowflakeIdGenerator
    private repository: IUserRepository
    private emailService: IEmailService
    private dateTimeProvider: IDateTimeProvider
    
    // Constructor con DI
    constructor(idGenerator, repository, emailService, dateTimeProvider, language)
    
    // Handler - Entry point
    async function Handler(input: DataIn): Result<DataOut> {
        try {
            #region Clean
            #region Validation
            #region Business Rules
            #region Process
        }
        catch {
            return Error
        }
    }
    
    // Private Mappers
    private function MapToDataOut(entity): DataOut
}
```

**Ver implementaciones completas en:**
- **C# Examples**: Artefacto separado con c√≥digo completo
- **Python Examples**: Artefacto separado con c√≥digo completo
- **TypeScript Examples**: Artefacto separado con c√≥digo completo

---

## 4 Secciones del Handler (Commands)

**Los Commands siguen una estructura de 4 secciones en orden:**

### Secci√≥n 1: Clean (Sanitizaci√≥n)

**Prop√≥sito:** Limpiar y normalizar datos de entrada antes de cualquier validaci√≥n.

**Responsabilidades:**
- Remover caracteres especiales no deseados
- Trim espacios en blanco
- Normalizar formato (lowercase, uppercase)
- Remover saltos de l√≠nea, tabs, etc.
- Limpiar n√∫meros (remover comas, s√≠mbolos de moneda)

**NO hace:**
- Validar datos
- Consultar base de datos
- L√≥gica de negocio

**Ejemplo:**
```
#region Clean
input.Email = Clean(input.Email).ToLower()
input.Phone = CleanPhone(input.Phone)
input.Name = Clean(input.Name)
#endregion
```

### Secci√≥n 2: Validation (Validaci√≥n de Formato)

**Prop√≥sito:** Verificar que los datos cumplan requisitos de formato y estructura.

**Responsabilidades:**
- Campos requeridos
- Longitud m√≠nima/m√°xima
- Formato de email, tel√©fono, URL
- Rangos num√©ricos (min/max)
- Expresiones regulares

**NO hace:**
- Consultar base de datos
- Verificar reglas de negocio complejas
- Modificar datos

**Retorna:** `Result<T>` con `State = Invalid` y **c√≥digo estructurado**

**C√≥digo obligatorio:** `[OPERACION]:VALIDATION:[RAZON_ESPECIFICA]`

**Ejemplo:**
```
#region Validation
prefix = "USER_CREATE"

if (IsNullOrEmpty(input.Email)) {
    return Result<DataOut>(
        state: INVALID,
        code: prefix + ":VALIDATION:EMAIL_REQUIRED",  // ‚Üê C√≥digo estructurado
        message: Messages.Get(language, "EmailRequired")
    )
}

if (Length(input.Password) < 8) {
    return Result<DataOut>(
        state: INVALID,
        code: prefix + ":VALIDATION:PASSWORD_TOO_SHORT",  // ‚Üê C√≥digo estructurado
        message: Messages.Get(language, "PasswordTooShort")
    )
}

if (input.Age < 18 OR input.Age > 120) {
    return Result<DataOut>(
        state: INVALID,
        code: prefix + ":VALIDATION:INVALID_AGE_RANGE",  // ‚Üê C√≥digo estructurado
        message: Messages.Get(language, "InvalidAgeRange")
    )
}
#endregion
```

**C√≥digos t√≠picos de validaci√≥n:**
- `USER_CREATE:VALIDATION:EMAIL_REQUIRED`
- `USER_CREATE:VALIDATION:EMAIL_INVALID_FORMAT`
- `USER_CREATE:VALIDATION:PASSWORD_TOO_SHORT`
- `ORDER_CREATE:VALIDATION:AMOUNT_OUT_OF_RANGE`
- `ORDER_CREATE:VALIDATION:QUANTITY_REQUIRED`

### Secci√≥n 3: Business Rules (Reglas de Negocio)

**Prop√≥sito:** Verificar reglas de negocio que pueden requerir consultas a la base de datos.

**Responsabilidades:**
- Verificar existencia de registros
- Validar unicidad (email no duplicado)
- Verificar permisos y autorizaciones
- Validar estados (usuario activo, orden cancelable)
- Verificar l√≠mites (cuota alcanzada, m√°ximo de registros)
- Validar relaciones entre entidades

**S√ç puede:**
- Consultar base de datos (SOLO lectura)
- Llamar otros Queries
- Verificar condiciones complejas

**NO hace:**
- Modificar base de datos
- Crear/actualizar/eliminar registros
- Ejecutar el proceso principal

**Retorna:** `Result<T>` con `State = Unsuccess` si falla una regla

**Ejemplo:**
```
#region Business Rules
existingUser = await repository.GetByEmail(input.Email)
if (existingUser != null) {
    return Result<DataOut>(
        state: UNSUCCESS,
        message: Messages.Get(language, "EmailExists"),
        code: prefix + ":EMAIL_EXISTS"
    )
}

userCount = await repository.CountByOrganization(input.OrganizationId)
if (userCount >= Settings.MaxUsersPerOrganization) {
    return Result<DataOut>(
        state: UNSUCCESS,
        message: Messages.Get(language, "UserLimitReached"),
        code: prefix + ":USER_LIMIT_REACHED"
    )
}
#endregion
```

### Secci√≥n 4: Process (Proceso Principal)

**Prop√≥sito:** Ejecutar la operaci√≥n principal si todas las validaciones y reglas pasaron.

**Responsabilidades:**
- Crear/actualizar/eliminar registros
- Ejecutar transacciones
- Llamar servicios externos (email, SMS, etc.)
- Generar tokens, c√≥digos
- Generar Snowflake IDs
- Crear registros relacionados

**Retorna:** `Result<T>` con `State = Success` y `Data` poblada

**Ejemplo:**
```
#region Process
// Generate Snowflake ID BEFORE creating entity
userId = idGenerator.GenerateId()

user = new User {
    userId: userId,              // Pre-generated Snowflake ID
    email: input.Email,
    name: input.Name,
    passwordHash: HashPassword(input.Password),
    createdAt: dateTimeProvider.UtcNow(),  // Always UTC
    status: "active"
}

await repository.Create(user)
await emailService.SendWelcomeEmail(user.Email, user.Name)

return Result<DataOut>(
    state: SUCCESS,
    message: empty Messages,
    code: prefix + ":SUCCESS",
    data: MapToDataOut(user)
)
#endregion
```

### Notas Importantes

**¬øSon obligatorias todas las secciones?**
- ‚ùå NO todas son obligatorias en todos los casos
- ‚úÖ S√ç debes seguir el ORDEN si usas las secciones
- ‚úÖ Queries generalmente solo tienen #region Process

**Regla de Oro:**
> Si una secci√≥n no es necesaria, om√≠tela. Pero si la usas, respeta el orden: Clean ‚Üí Validation ‚Üí Business Rules ‚Üí Process

---

## Interfaces y Dependency Injection

### Interfaces en el Core

**Pseudoc√≥digo:**
```
// IUserRepository
interface IUserRepository {
    GetById(id: long): User
    GetByEmail(email: string): User
    ExistsByEmail(email: string): boolean
    GetAll(): Array<User>
    Create(user: User): void
    Update(user: User): void
}

// IEmailService
interface IEmailService {
    SendEmail(to: string, subject: string, body: string): void
    SendWelcomeEmail(email: string, name: string): void
}

// ISnowflakeIdGenerator
interface ISnowflakeIdGenerator {
    GenerateId(): long
}

// IDateTimeProvider
interface IDateTimeProvider {
    UtcNow(): datetime  // Always returns UTC
}
```

### Implementaciones en Infrastructure

**Pseudoc√≥digo:**
```
// UserRepository - SQL Implementation
class UserRepository implements IUserRepository {
    private dbContext: DbContext
    
    constructor(dbContext: DbContext)
    
    function GetById(id: long): User {
        return dbContext.Users.FindById(id)
    }
    
    function Create(user: User): void {
        dbContext.Users.Add(user)
        dbContext.SaveChanges()
    }
}

// SnowflakeIdGenerator
class SnowflakeIdGenerator implements ISnowflakeIdGenerator {
    private nodeId: integer
    private sequence: integer
    private lastTimestamp: long
    
    constructor(nodeId: integer)  // Unique per server
    
    function GenerateId(): long {
        timestamp = GetCurrentTimestampMillis()
        // Combine: timestamp (41 bits) + nodeId (10 bits) + sequence (12 bits)
        return ((timestamp - EPOCH) << 22) | (nodeId << 12) | sequence
    }
}

// DateTimeProvider - Always UTC
class DateTimeProvider implements IDateTimeProvider {
    function UtcNow(): datetime {
        return GetSystemTimeInUTC()  // Never local time!
    }
}
```

### Configuraci√≥n de Dependency Injection

**Pseudoc√≥digo:**
```
// Application Startup

// Get nodeId from configuration (different per server)
nodeId = Configuration.Get("NodeId", default: 0)

// Infrastructure - Singleton
services.RegisterSingleton<ISnowflakeIdGenerator>(
    new SnowflakeIdGenerator(nodeId)
)
services.RegisterSingleton<IDateTimeProvider>(
    new DateTimeProvider()
)

// Infrastructure - Scoped
services.RegisterScoped<IUserRepository, UserRepository>()
services.RegisterScoped<IEmailService, EmailService>()

// Core Commands and Queries - Scoped
services.RegisterScoped<UserCCreate>()
services.RegisterScoped<UserQGetByID>()

// The Core automatically receives injected implementations!
```

---

## Snowflake IDs - Recomendaci√≥n Fuerte

### ¬øPor qu√© Snowflake IDs?

**Problemas con Auto-Increment:**
- ‚ùå Requiere base de datos centralizada
- ‚ùå Bottleneck en alta concurrencia
- ‚ùå Revela informaci√≥n del negocio (ID 1000 = 1000 usuarios)
- ‚ùå Problemas en sistemas distribuidos
- ‚ùå Conflictos al mergear bases de datos

**Ventajas de Snowflake:**
- ‚úÖ Generaci√≥n distribuida sin coordinaci√≥n
- ‚úÖ Performance alta (sin consultar DB)
- ‚úÖ Ordenamiento cronol√≥gico autom√°tico
- ‚úÖ √önico globalmente
- ‚úÖ Ideal para microservicios

### Implementaci√≥n

**Uso en Commands:**
```
class UserCCreate {
    private idGenerator: ISnowflakeIdGenerator
    
    async function Handler(input: DataIn): Result<DataOut> {
        // Generate Snowflake ID BEFORE inserting
        userId = idGenerator.GenerateId()
        
        user = new User {
            userId: userId,  // Pre-generated Snowflake ID
            email: input.email
        }
        
        await repository.Create(user)
        
        return Success with userId
    }
}
```

### Configuraci√≥n por Servidor

```
# Server 1
NODE_ID=0

# Server 2
NODE_ID=1

# Server 3
NODE_ID=2

# Development
NODE_ID=100

# Testing
NODE_ID=200
```

**CR√çTICO:** Cada servidor/proceso DEBE tener un NODE_ID √∫nico para garantizar IDs √∫nicos globalmente.

---

## Helpers de Sanitizaci√≥n

**Pseudoc√≥digo:**
```
function Clean(text: string): string {
    return text
        .Replace("\r", "")
        .Replace("\n", "")
        .Replace("\t", "")
        .Trim()
}

function CleanPhone(text: string): string {
    return CleanNumber(text)
        .Replace("(", "")
        .Replace(")", "")
        .Replace(" ", "")
        .Replace("-", "")
}

function CleanNumber(text: string): string {
    return Clean(text)
        .Replace(",", "")
        .Replace("$", "")
}
```

---

## Reglas de Oro

### üîê **16 Reglas Inquebrantables**

1. **Expl√≠cito sobre Impl√≠cito**: SIEMPRE priorizar claridad sobre brevedad
2. **UTC Everywhere in Core**: Core NUNCA maneja otra timezone que no sea UTC
3. **Handler Method**: Toda Query/Command tiene un m√©todo `Handler()` como punto de entrada
4. **Result Envelope**: TODO retorna `Result<T>` con estados definidos
5. **Nested Structure per Operation**: DataIn, DataOut, Messages en el mismo archivo
6. **JSON Communication**: Toda comunicaci√≥n entre capas es JSON
7. **Dependency Inversion**: Core define interfaces, Infrastructure las implementa
8. **No Direct Infrastructure in Core**: Core NUNCA instancia clases de Infrastructure
9. **Dependency Injection**: Todas las dependencias se inyectan
10. **Timezone Conversion Only in Presentation**: API layer maneja conversiones TZ
11. **Messages Required**: Toda operaci√≥n tiene Messages para multiidioma
12. **Entity = Persistence Model**: Entity representa exactamente el modelo de DB
13. **4 Sections Order**: Clean ‚Üí Validation ‚Üí Business Rules ‚Üí Process
14. **Infrastructure Concerns in Infrastructure**: Cache, logging, m√©tricas = Infrastructure
15. **Core is Pure Business Logic**: Core solo contiene l√≥gica de negocio
16. **Snowflake IDs Strongly Recommended**: Usar Snowflake IDs en entidades principales

---

## Gu√≠a de Implementaci√≥n

### Paso 1: Crear Estructura de Proyectos

1. Crear proyecto **Core** (sin dependencias externas)
2. Crear proyecto **Infrastructure** (referencia Core)
3. Crear proyecto **API** (referencia Core + Infrastructure)
4. Crear proyecto **Helpers** (opcional, utilidades)

### Paso 2: Definir Interfaces en Core

```
Core/Interfaces/
  ‚îú‚îÄ‚îÄ IUserRepository
  ‚îú‚îÄ‚îÄ IEmailService
  ‚îú‚îÄ‚îÄ ISnowflakeIdGenerator
  ‚îî‚îÄ‚îÄ IDateTimeProvider
```

### Paso 3: Crear Entity

```
Core/Entities/UsersQC/User.{lang}

User {
    userId: long  // Snowflake ID
    email: string
    name: string
    createdAt: datetime  // UTC
}
```

### Paso 4: Implementar Command/Query

```
Core/Entities/UsersQC/UserCCreate.{lang}

class UserCCreate {
    class DataIn { ... }
    class DataOut { ... }
    static class Messages { ... }
    
    async function Handler(input: DataIn): Result<DataOut> {
        #region Clean
        #region Validation
        #region Business Rules
        #region Process
    }
}
```

### Paso 5: Implementar Infrastructure

```
Infrastructure/Database/UserRepository.{lang}
Infrastructure/IdGeneration/SnowflakeIdGenerator.{lang}
Infrastructure/Services/DateTimeProvider.{lang}
```

### Paso 6: Configurar Dependency Injection

```
// Get nodeId from configuration
nodeId = Config.Get("NodeId")

// Register infrastructure
services.RegisterSingleton<ISnowflakeIdGenerator>(new SnowflakeIdGenerator(nodeId))
services.RegisterScoped<IUserRepository, UserRepository>()

// Register commands/queries
services.RegisterScoped<UserCCreate>()
```

### Paso 7: Crear Controller

```
API/Controllers/UsersController.{lang}

class UsersController {
    private createCommand: UserCCreate
    
    [POST("/api/users")]
    async function Create(request: UserCCreate.DataIn, userTimezone: string) {
        result = await createCommand.Handler(request)
        
        if (result.state == SUCCESS) {
            // Convert UTC to user timezone
            response = ConvertDatesToUserTimezone(result.data, userTimezone)
            return HTTP 201 with response
        }
        else if (result.state == INVALID) {
            return HTTP 400 with result.message
        }
    }
}
```

---

## Checklist de Implementaci√≥n

### Core Layer
- [ ] Proyecto Core creado sin dependencias externas
- [ ] Carpeta `Entities/` creada
- [ ] Carpeta `Interfaces/` creada
- [ ] Por cada entidad, crear carpeta `[Entity]QC/`
- [ ] Entity sin sufijos creada (User.cs, Order.cs)
- [ ] Cada Query/Command tiene estructura nested (DataIn/DataOut/Messages)
- [ ] M√©todo `Handler()` como punto de entrada
- [ ] TODO el sistema maneja fechas en UTC
- [ ] Cero referencias a infraestructura en Core
- [ ] Interfaces definidas para todos los servicios externos
- [ ] Comunicaci√≥n en JSON

### Infrastructure Layer
- [ ] Implementaciones de repositorios
- [ ] SnowflakeIdGenerator con NODE_ID √∫nico por servidor
- [ ] DateTimeProvider siempre retorna UTC
- [ ] Implementaciones de servicios externos
- [ ] Base de datos guarda fechas en UTC
- [ ] No contiene l√≥gica de negocio

### API/Presentation Layer
- [ ] Middleware de autenticaci√≥n configurado
- [ ] Middleware de autorizaci√≥n configurado
- [ ] Controllers llaman m√©todo `Handler()` de Commands/Queries
- [ ] Conversi√≥n de fechas: User TZ ‚Üí UTC (entrada)
- [ ] Conversi√≥n de fechas: UTC ‚Üí User TZ (salida)
- [ ] Validaci√≥n de entrada implementada
- [ ] Manejo de errores centralizado
- [ ] Documentaci√≥n API (Swagger/GraphiQL)

### Naming Conventions
- [ ] Archivos/Clases: `[Entity][Q|C][Action]`
- [ ] Nested classes: `DataIn`, `DataOut`, `Messages`
- [ ] Entity: `[Entity]` (sin sufijos)
- [ ] M√©todo principal: `Handler()`

### Testing
- [ ] Tests unitarios de Core (sin mocks complejos)
- [ ] Tests verifican manejo correcto de UTC
- [ ] Tests de conversi√≥n timezone en API
- [ ] Tests de mensajes multiidioma
- [ ] Tests verifican Snowflake IDs √∫nicos

---

## Preguntas Frecuentes

**Q: ¬øPor qu√© 2 archivos en lugar de 5?**
A: La nueva estructura nested agrupa todo lo relacionado a una operaci√≥n en un solo archivo, mejorando cohesi√≥n y reduciendo navegaci√≥n. Antes: 5 archivos dispersos. Ahora: Entity + 1 archivo con todo nested = 60% menos archivos, 100% m√°s cohesi√≥n.

**Q: ¬øPor qu√© DataIn/DataOut y no Input/Output o Request/Response?**
A: Principio "Expl√≠cito sobre Impl√≠cito". Input/Output son gen√©ricos y pueden referirse a I/O de sistema. Request/Response implican contexto HTTP. DataIn/DataOut son expl√≠citos: datos que entran/salen del Handler.

**Q: ¬øPuedo usar esta arquitectura con lenguajes din√°micos como Python/Node.js?**
A: S√≠, los principios son agn√≥sticos. Python usa nested classes, TypeScript usa namespaces. Los ejemplos completos est√°n en los artefactos separados.

**Q: ¬øQu√© pasa si una operaci√≥n no necesita Input DTO?**
A: No lo crees. Ejemplo: `UserQGetAll` no necesita par√°metros, solo tiene DataOut. La clase Messages sigue siendo necesaria para posibles mensajes de error.

**Q: ¬øD√≥nde van las validaciones de entrada?**
A: Validaciones **t√©cnicas** (formato email, longitud) van en la secci√≥n Validation del Handler. Validaciones de **negocio** (email ya existe) van en la secci√≥n Business Rules.

**Q: ¬øC√≥mo manejo transacciones de base de datos?**
A: La infraestructura maneja transacciones. El Core define los l√≠mites mediante el patr√≥n Unit of Work. El Handler ejecuta operaciones, la infraestructura asegura atomicidad.

**Q: ¬øUn Command puede llamar a otro Command?**
A: S√≠, pero con precauci√≥n. Si la l√≥gica es compleja, considera extraer a clases auxiliares o servicios de dominio. Evita cadenas largas de Commands llamando Commands.

**Q: ¬øC√≥mo traduzco mensajes din√°micamente?**
A: La clase Messages recibe el idioma. El Presentation Layer detecta el idioma del usuario (header, JWT, configuraci√≥n) y lo pasa al crear el Command/Query.

**Q: ¬øPor qu√© JSON para comunicaci√≥n interna?**
A: Estandarizaci√≥n y consistencia. Facilita debugging, logging, y hace el sistema agn√≥stico de tecnolog√≠a. Puedes serializar/deserializar f√°cilmente entre capas.

**Q: ¬øQu√© hago con fechas que el usuario env√≠a?**
A: Si el usuario env√≠a una fecha (ej: "agendar para ma√±ana a las 3pm"), el Presentation Layer DEBE convertirla del timezone del usuario a UTC antes de enviarla al Core. El Core solo trabaja UTC.

**Q: ¬øLa Entity puede tener l√≥gica de negocio?**
A: La Entity es un modelo de datos simple (POCO/Plain Object). La l√≥gica de negocio va en Commands/Queries. La Entity solo tiene propiedades para persistencia.

**Q: ¬øPuedo usar ORMs como Entity Framework, SQLAlchemy, TypeORM?**
A: S√≠. Los ORMs van en la capa Infrastructure. El Core solo conoce las interfaces de repositorios, no la implementaci√≥n concreta.

**Q: ¬øC√≥mo testeo un Command que usa m√∫ltiples servicios?**
A: Mock las interfaces. Como el Core depende de abstracciones (IUserRepository, IEmailService), puedes mockearlas f√°cilmente en tests unitarios sin necesitar bases de datos reales.

**Q: ¬øEsta arquitectura funciona con microservicios?**
A: S√≠. Cada microservicio puede seguir esta arquitectura internamente. La comunicaci√≥n entre microservicios ocurre en la capa Infrastructure (HTTP clients, message queues).

**Q: ¬øCu√°ndo NO usar esta arquitectura?**
A: Para proyectos muy simples (< 5 entidades, CRUD b√°sico sin l√≥gica), scripts de una sola vez, prototipos r√°pidos, o cuando el equipo no puede comprometerse a seguir las convenciones.

**Q: ¬øPor qu√© Snowflake IDs en lugar de auto-increment?**
A: Snowflake IDs son generados localmente sin consultar la base de datos, funcionan en sistemas distribuidos sin coordinaci√≥n, no revelan informaci√≥n de negocio, y son ideales para microservicios y alta concurrencia.

**Q: ¬øQu√© pasa si dos servidores generan el mismo Snowflake ID?**
A: Imposible si cada servidor tiene un NODE_ID √∫nico. Los primeros 10 bits del ID identifican el nodo, garantizando unicidad global. Es cr√≠tico que cada servidor/proceso tenga su propio NODE_ID.

**Q: ¬øC√≥mo migro de auto-increment a Snowflake?**
A: Agrega columna snowflake_id, genera IDs para registros existentes, usa dual-ID temporalmente, migra referencias gradualmente. O simplemente usa Snowflake para todas las entidades nuevas.

**Q: ¬øLos Snowflake IDs son compatibles con bases de datos relacionales?**
A: S√≠, totalmente. Se almacenan como BIGINT (64 bits). Funcionan perfectamente con PostgreSQL, MySQL, SQL Server, etc. Solo aseg√∫rate de usar el tipo de dato correcto (long/bigint).

**Q: ¬øQu√© pasa si el reloj del servidor retrocede?**
A: El generador de Snowflake lanza una excepci√≥n. Usa NTP para sincronizar relojes y monitorea clock drift. Nunca permitas que el sistema contin√∫e si detecta retroceso de reloj.

---

## Ventajas y Limitaciones

### ‚úÖ Ventajas

1. **Testabilidad Extrema**: Core testeable sin bases de datos o servicios externos
2. **Claridad**: Cualquier desarrollador encuentra el c√≥digo r√°pidamente
3. **Flexibilidad de Protocolo**: Cambiar de REST a GraphQL sin tocar Core
4. **Mantenibilidad**: C√≥digo organizado por concepto de negocio
5. **Onboarding R√°pido**: Convenciones claras facilitan incorporaci√≥n de nuevos devs
6. **Evoluci√≥n Independiente**: Core y API evolucionan por separado
7. **Menos Archivos**: 60% reducci√≥n con estructura nested
8. **Nombres Expl√≠citos**: DataIn/DataOut son autoexplicativos
9. **Distribuci√≥n**: Snowflake IDs permiten sistemas distribuidos sin conflictos
10. **Performance**: IDs generados localmente sin consultar DB

### ‚ö†Ô∏è Consideraciones

1. **Curva de Aprendizaje Inicial**: Requiere disciplina en seguir convenciones
2. **Archivos M√°s Largos**: Estructura nested significa archivos de 200-400 l√≠neas
3. **Boilerplate**: M√°s c√≥digo de configuraci√≥n inicial
4. **Overkill para Proyectos Simples**: CRUD b√°sicos pueden no justificar esta arquitectura
5. **Sincronizaci√≥n de Relojes**: Snowflake IDs requieren NTP para evitar conflictos

### üìä Trade-offs

| Aspecto | Trade-off |
|---------|-----------|
| Setup inicial | üî¥ M√°s complejo ‚Üí üü¢ Paga dividendos en mantenimiento |
| Archivos | üü¢ 60% menos archivos ‚Üí üî¥ Archivos m√°s largos |
| Acoplamiento | üü¢ Bajo acoplamiento ‚Üí üî¥ M√°s interfaces |
| Tests | üü¢ Muy f√°cil ‚Üí üî¥ Requiere configurar DI |
| Multiidioma | üü¢ Soporte nativo ‚Üí üî¥ Clase Messages por operaci√≥n |
| Timezones | üü¢ Consistencia UTC ‚Üí üî¥ Conversi√≥n en cada endpoint |
| IDs | üü¢ Snowflake distribuido ‚Üí üî¥ Requiere NTP y NODE_ID √∫nico |

---

## Escalabilidad

### Proyectos Peque√±os (< 10 entidades)
```
MyProject.Core/
MyProject.Infrastructure/
MyProject.API.REST/
```

### Proyectos Medianos (10-50 entidades)
```
MyProject.Core/
MyProject.Infrastructure/
  ‚îú‚îÄ‚îÄ Database/
  ‚îú‚îÄ‚îÄ Services/
  ‚îú‚îÄ‚îÄ IdGeneration/
  ‚îî‚îÄ‚îÄ Cache/
MyProject.API.REST/
MyProject.API.GraphQL/
```

### Proyectos Grandes (50+ entidades)
```
MyProject.Core/
  ‚îú‚îÄ‚îÄ Entities/
  ‚îÇ   ‚îú‚îÄ‚îÄ Users/          # Bounded Context
  ‚îÇ   ‚îú‚îÄ‚îÄ Orders/
  ‚îÇ   ‚îî‚îÄ‚îÄ Billing/
MyProject.Infrastructure/
MyProject.API.REST/
MyProject.API.GraphQL/
MyProject.API.gRPC/
MyProject.Workers/        # Background jobs
```

### Microservicios

Cada microservicio usa la misma arquitectura:
```
UserService/
  ‚îú‚îÄ‚îÄ UserService.Core/
  ‚îú‚îÄ‚îÄ UserService.Infrastructure/
  ‚îî‚îÄ‚îÄ UserService.API/

OrderService/
  ‚îú‚îÄ‚îÄ OrderService.Core/
  ‚îú‚îÄ‚îÄ OrderService.Infrastructure/
  ‚îî‚îÄ‚îÄ OrderService.API/
```

Cada servicio tiene su propio NODE_ID range para Snowflake IDs:
```
UserService:   NODE_ID = 0-99
OrderService:  NODE_ID = 100-199
BillingService: NODE_ID = 200-299
```

---

## Ejemplos de Uso

### Crear Usuario

**Controller (Presentation Layer):**
```
[POST("/api/users")]
async function CreateUser(
    request: UserCCreate.DataIn,
    userTimezone: string = "UTC"
) {
    // Timezone del usuario viene en header
    result = await userCCreateCommand.Handler(request)
    
    if (result.state == SUCCESS) {
        // Convert UTC dates to user timezone
        response = {
            userId: result.data.userId,
            email: result.data.email,
            createdAt: ConvertToUserTimezone(result.data.createdAt, userTimezone)
        }
        return HTTP 201 with response
    }
    else if (result.state == INVALID) {
        return HTTP 400 with {
            code: result.code,
            message: result.message.userMessage
        }
    }
}
```

**Command (Core Layer):**
```
class UserCCreate {
    async function Handler(input: DataIn): Result<DataOut> {
        try {
            // Clean
            input.email = Clean(input.email).ToLower()
            
            // Validation
            if (IsEmpty(input.email)) {
                return Invalid("EmailRequired")
            }
            
            // Business Rules
            if (await repository.ExistsByEmail(input.email)) {
                return Unsuccess("EmailExists")
            }
            
            // Process
            userId = idGenerator.GenerateId()
            user = new User {
                userId: userId,
                email: input.email,
                createdAt: dateTimeProvider.UtcNow()  // UTC
            }
            await repository.Create(user)
            
            return Success with MapToDataOut(user)
        }
        catch {
            return Error
        }
    }
}
```

### Consultar Usuario

**Controller:**
```
[GET("/api/users/{id}")]
async function GetUser(
    id: long,
    userTimezone: string = "UTC"
) {
    input = new UserQGetByID.DataIn { userId: id }
    result = await userQGetByIDQuery.Handler(input)
    
    if (result.state == SUCCESS) {
        response = {
            userId: result.data.userId,
            email: result.data.email,
            createdAt: ConvertToUserTimezone(result.data.createdAt, userTimezone)
        }
        return HTTP 200 with response
    }
    else if (result.state == EMPTY) {
        return HTTP 404
    }
}
```

**Query (Core):**
```
class UserQGetByID {
    async function Handler(input: DataIn): Result<DataOut> {
        user = await repository.GetById(input.userId)
        
        if (user == null) {
            return Empty()
        }
        
        return Success with MapToDataOut(user)
    }
}
```

---

## Recursos y Herramientas

### Sobre el Nombre de la Arquitectura

**"Entity-Driven Clean Architecture"** es √∫nico en su combinaci√≥n espec√≠fica de:
1. Organizaci√≥n estricta por entidades (no por capas t√©cnicas)
2. Convenci√≥n de nomenclatura QC expl√≠cita
3. Patr√≥n Handler obligatorio
4. Estructura nested con DataIn/DataOut/Messages
5. Sistema UTC estricto
6. Result Envelope estandarizado
7. Snowflake IDs como recomendaci√≥n
8. Principio "Expl√≠cito sobre Impl√≠cito"

Conceptos relacionados pero diferentes:
- **Clean Architecture** (Robert C. Martin) - Principios base
- **Domain-Driven Design** (Eric Evans) - Enfoque en dominio
- **CQRS Pattern** - Separaci√≥n Commands/Queries
- **Hexagonal Architecture** - Ports and Adapters

### Herramientas Recomendadas

**Dependency Injection:**
- C#: Microsoft.Extensions.DependencyInjection, Autofac
- Python: FastAPI Dependencies, Dependency Injector
- TypeScript: InversifyJS, tsyringe

**Testing:**
- C#: xUnit, NUnit, Moq
- Python: pytest, unittest.mock
- TypeScript: Jest, Mocha

**Snowflake ID Generators:**
- C#: IdGen library
- Python: pysnowflake, python-snowflake
- TypeScript: flake-idgen

**Documentaci√≥n API:**
- REST: Swagger/OpenAPI
- GraphQL: GraphiQL, Apollo Studio

### Implementaciones de Referencia

Ver artefactos separados con c√≥digo completo funcional:
- **C# Examples**: ~600 l√≠neas con ASP.NET Core, Entity Framework
- **Python Examples**: ~550 l√≠neas con FastAPI, SQLAlchemy
- **TypeScript Examples**: ~650 l√≠neas con Express, TypeORM

---

## Contribuciones

Este white paper es un documento vivo. Sugerencias de mejora son bienvenidas.

### C√≥mo Contribuir
1. Fork el repositorio
2. Crea branch con tu mejora
3. Env√≠a Pull Request con descripci√≥n clara

---

## Licencia

Este documento y arquitectura est√°n bajo licencia MIT. Libre de usar en proyectos comerciales y open source.

---

## Changelog

### v1.0.0 (2025)
- Versi√≥n inicial del white paper
- Estructura nested con DataIn/DataOut/Messages
- Principio "Expl√≠cito sobre Impl√≠cito"
- Convenci√≥n QC establecida
- Snowflake IDs recomendados
- Ejemplos en C#, Python, TypeScript
- 16 Reglas de Oro
- Result Envelope Pattern
- UTC estricto documentado
- 4 secciones del Handler
- Reducci√≥n de 60% en archivos

---

## Resumen Final

**Entity-Driven Clean Architecture** es una arquitectura pr√°ctica, probada y escalable para backends modernos que prioriza:

1. **Claridad**: Expl√≠cito sobre impl√≠cito en todo momento
2. **Organizaci√≥n**: Por entidades de negocio, no por capas t√©cnicas
3. **Testabilidad**: Core 100% independiente de infraestructura
4. **Mantenibilidad**: Estructura nested cohesiva con 60% menos archivos
5. **Escalabilidad**: Desde proyectos peque√±os hasta microservicios
6. **Distribuci√≥n**: Snowflake IDs para sistemas distribuidos
7. **Consistencia**: UTC en Core, conversi√≥n en Presentation
8. **Flexibilidad**: Agn√≥stica de protocolo (REST/GraphQL/gRPC)

**Filosof√≠a Core:**
> "El c√≥digo debe ser tan expl√≠cito que un desarrollador nuevo pueda entender qu√© hace una operaci√≥n simplemente leyendo el nombre del archivo y sus clases nested. La arquitectura debe ayudar, no estorbar."

**Empieza hoy:**
1. Crea tu primer Command con DataIn/DataOut/Messages
2. Implementa Result Envelope
3. Usa Snowflake IDs desde el inicio
4. Mant√©n UTC estricto en Core
5. Sigue el orden Clean ‚Üí Validation ‚Üí Business Rules ‚Üí Process

---

**¬øPreguntas? ¬øFeedback?**

Este white paper documenta una arquitectura real, usada en producci√≥n, que ha demostrado su valor en m√∫ltiples proyectos. Los ejemplos de c√≥digo en los artefactos separados son funcionales y listos para usar.

**Ver implementaciones completas:**
- [C# Examples](link-to-artifact)
- [Python Examples](link-to-artifact)  
- [TypeScript Examples](link-to-artifact)

---

**Creado con ‚ù§Ô∏è para la comunidad de desarrolladores**

*"La mejor arquitectura es aquella que hace el c√≥digo tan obvio que los comentarios son innecesarios."*
